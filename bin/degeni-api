#!/usr/bin/env python3
"""
DEGENI API Server - Real Live Backend
by BITZY.ID
"""

import os
import json
import subprocess
import glob
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import threading

PORT = 8321
HOME = os.path.expanduser("~")
AUTH_DIR = os.path.join(HOME, ".cli-proxy-api")
PROXY_DIR = os.path.join(HOME, "cliproxyapi")
PROXY_LOG = os.path.join(PROXY_DIR, "cliproxyapi.log")
CONFIG_FILE = os.path.join(PROXY_DIR, "config.yaml")

class DEGENIHandler(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # Suppress logs
    
    def send_cors_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
    
    def send_json(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.send_cors_headers()
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())
    
    def _get_api_key(self):
        """Extract API key from config file using regex"""
        import re
        try:
            with open(CONFIG_FILE, 'r') as f:
                content = f.read()
                match = re.search(r'sk-[A-Za-z0-9]+', content)
                if match:
                    return match.group(0)
        except:
            pass
        return "sk-default"
    
    def do_OPTIONS(self):
        self.send_response(200)
        self.send_cors_headers()
        self.end_headers()
    
    def do_GET(self):
        path = urlparse(self.path).path
        
        if path == '/api/status':
            self.get_status()
        elif path == '/api/accounts':
            self.get_accounts()
        elif path == '/api/usage':
            self.get_usage()
        elif path == '/api/models':
            self.get_models()
        elif path == '/api/logs':
            self.get_logs()
        elif path == '/api/config':
            self.get_config()
        else:
            self.send_json({'error': 'Not found'}, 404)
    
    def do_POST(self):
        path = urlparse(self.path).path
        
        if path == '/api/restart':
            self.restart_proxy()
        elif path == '/api/test':
            self.test_connection()
        elif path == '/api/account/toggle':
            content_length = int(self.headers.get('Content-Length', 0))
            body = json.loads(self.rfile.read(content_length)) if content_length else {}
            self.toggle_account(body.get('filename'))
        elif path == '/api/model/switch':
            content_length = int(self.headers.get('Content-Length', 0))
            body = json.loads(self.rfile.read(content_length)) if content_length else {}
            self.switch_model(body.get('model'))
        else:
            self.send_json({'error': 'Not found'}, 404)
    
    def get_status(self):
        """Get proxy server status"""
        try:
            result = subprocess.run(['pgrep', '-f', 'cli-proxy-api'], capture_output=True, text=True)
            is_running = result.returncode == 0
            pid = result.stdout.strip().split('\n')[0] if is_running else None
            
            # Count accounts
            antigravity = len(glob.glob(os.path.join(AUTH_DIR, 'antigravity-*.json')))
            gemini = len([f for f in glob.glob(os.path.join(AUTH_DIR, '*.json')) if 'antigravity' not in f])
            disabled = len(glob.glob(os.path.join(AUTH_DIR, '*.disabled')))
            
            # Check for limit/quota issues in recent logs
            limit_hit = False
            limit_model = ''
            limit_msg = ''
            
            if os.path.exists(PROXY_LOG):
                try:
                    result_log = subprocess.run(['tail', '-100', PROXY_LOG], capture_output=True, text=True)
                    log_content = result_log.stdout.lower()
                    
                    # Check for various limit indicators
                    limit_keywords = [
                        'payment_required', 'quota', 'rate limit', 'limit exceeded',
                        'too many requests', '429', 'resource_exhausted', 
                        'billing', 'exceeded', 'daily limit'
                    ]
                    
                    for keyword in limit_keywords:
                        if keyword in log_content:
                            limit_hit = True
                            # Try to extract model name from log
                            for line in result_log.stdout.split('\n')[-20:]:
                                if keyword in line.lower():
                                    limit_msg = line[:100]
                                    # Extract model if present
                                    if 'claude' in line.lower():
                                        limit_model = 'claude'
                                    elif 'gemini' in line.lower():
                                        limit_model = 'gemini'
                                    break
                            break
                except:
                    pass
            
            self.send_json({
                'online': is_running,
                'pid': pid,
                'accounts': {
                    'antigravity': antigravity,
                    'gemini': gemini,
                    'disabled': disabled,
                    'total': antigravity + gemini
                },
                'limit': {
                    'hit': limit_hit,
                    'model': limit_model,
                    'message': limit_msg
                }
            })
        except Exception as e:
            self.send_json({'error': str(e)}, 500)
    
    def get_accounts(self):
        """Get all registered accounts"""
        accounts = []
        
        # Antigravity accounts
        for f in glob.glob(os.path.join(AUTH_DIR, 'antigravity-*.json')):
            filename = os.path.basename(f)
            email = filename.replace('antigravity-', '').replace('.json', '').replace('_', '@').replace('@gmail@com', '@gmail.com')
            
            # Try to read project from file
            project = ''
            try:
                with open(f, 'r') as file:
                    data = json.load(file)
                    project = data.get('project_id', '')
            except:
                pass
            
            accounts.append({
                'type': 'antigravity',
                'email': email,
                'project': project,
                'filename': filename,
                'active': True,
                'path': f
            })
        
        # Disabled accounts
        for f in glob.glob(os.path.join(AUTH_DIR, '*.disabled')):
            filename = os.path.basename(f)
            email = filename.replace('antigravity-', '').replace('.json.disabled', '').replace('_', '@').replace('@gmail@com', '@gmail.com')
            accounts.append({
                'type': 'antigravity',
                'email': email,
                'project': '',
                'filename': filename,
                'active': False,
                'path': f
            })
        
        # Gemini CLI accounts
        for f in glob.glob(os.path.join(AUTH_DIR, '*.json')):
            if 'antigravity' not in f:
                filename = os.path.basename(f)
                accounts.append({
                    'type': 'gemini-cli',
                    'email': filename.replace('.json', ''),
                    'project': '',
                    'filename': filename,
                    'active': True,
                    'path': f
                })
        
        self.send_json({'accounts': accounts})
    
    def get_usage(self):
        """Get usage data per account with reset time"""
        import re
        from datetime import datetime, timedelta
        
        usage_data = []
        total_requests = 0
        
        # Get all active accounts
        accounts = []
        for f in glob.glob(os.path.join(AUTH_DIR, 'antigravity-*.json')):
            filename = os.path.basename(f)
            email = filename.replace('antigravity-', '').replace('.json', '').replace('_', '@').replace('@gmail@com', '@gmail.com')
            accounts.append({'email': email, 'filename': filename, 'path': f})
        
        # Parse logs for request counts and status
        log_content = ""
        if os.path.exists(PROXY_LOG):
            try:
                result = subprocess.run(['tail', '-500', PROXY_LOG], capture_output=True, text=True)
                log_content = result.stdout
            except:
                pass
        
        for acc in accounts:
            email = acc['email']
            email_pattern = email.split('@')[0]  # Match by username part
            
            # Count requests for this account (approximate from logs)
            request_count = log_content.lower().count(email_pattern.lower())
            if request_count == 0:
                # Estimate from 200 OK responses roughly
                request_count = log_content.count('200 |') // max(1, len(accounts))
            
            # Check if suspended or limited
            status = 'available'
            if f'suspended' in log_content.lower() and email_pattern.lower() in log_content.lower():
                status = 'suspended'
            elif 'payment_required' in log_content.lower() or 'quota' in log_content.lower():
                if email_pattern.lower() in log_content.lower():
                    status = 'limited'
            
            # Calculate usage percentage (daily limit ~500 requests estimate)
            daily_limit = 500
            percent = min(100, int((request_count / daily_limit) * 100))
            
            # Get last used time from logs
            last_used = '-'
            for line in log_content.split('\n')[-100:]:
                if email_pattern.lower() in line.lower() or '200 |' in line:
                    time_match = re.search(r'\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]', line)
                    if time_match:
                        last_used = time_match.group(1).split(' ')[1]
            
            total_requests += request_count
            
            usage_data.append({
                'email': email,
                'requests_today': request_count,
                'limit': daily_limit,
                'percent': percent,
                'status': status,
                'last_used': last_used
            })
        
        # Calculate next reset time (07:00 WIB = 00:00 UTC)
        now = datetime.now()
        reset_hour = 7  # 07:00 WIB
        if now.hour >= reset_hour:
            next_reset = (now + timedelta(days=1)).replace(hour=reset_hour, minute=0, second=0, microsecond=0)
        else:
            next_reset = now.replace(hour=reset_hour, minute=0, second=0, microsecond=0)
        
        hours_until_reset = int((next_reset - now).total_seconds() / 3600)
        minutes_until_reset = int(((next_reset - now).total_seconds() % 3600) / 60)
        
        # Sort by usage (lowest first for smart rotation)
        usage_data.sort(key=lambda x: (x['status'] != 'available', x['percent']))
        
        # Smart suggestion
        available_accounts = [a for a in usage_data if a['status'] == 'available']
        suggestion = available_accounts[0]['email'] if available_accounts else None
        
        self.send_json({
            'accounts': usage_data,
            'total_requests': total_requests,
            'next_reset': next_reset.strftime('%Y-%m-%d %H:%M WIB'),
            'reset_countdown': f'{hours_until_reset}h {minutes_until_reset}m',
            'suggestion': suggestion
        })
    
    def get_models(self):
        """Get available models from proxy API"""
        try:
            # Read API key from config using regex
            api_key = self._get_api_key()
            
            result = subprocess.run([
                'curl', '-s', 'http://localhost:8317/v1/models',
                '-H', f'Authorization: Bearer {api_key}'
            ], capture_output=True, text=True, timeout=10)
            
            data = json.loads(result.stdout)
            self.send_json(data)
        except Exception as e:
            self.send_json({'error': str(e), 'data': []}, 500)
    
    def get_logs(self):
        """Get recent logs"""
        logs = []
        try:
            if os.path.exists(PROXY_LOG):
                result = subprocess.run(['tail', '-50', PROXY_LOG], capture_output=True, text=True)
                for line in result.stdout.strip().split('\n'):
                    if line:
                        log_type = 'info'
                        if 'error' in line.lower() or 'failed' in line.lower():
                            log_type = 'error'
                        elif 'warn' in line.lower() or 'rate limit' in line.lower():
                            log_type = 'warn'
                        elif 'success' in line.lower() or '200' in line:
                            log_type = 'ok'
                        logs.append({'msg': line, 'type': log_type})
        except Exception as e:
            logs.append({'msg': str(e), 'type': 'error'})
        
        self.send_json({'logs': logs[-30:]})  # Last 30 entries
    
    def get_config(self):
        """Get current model config"""
        try:
            # Read from ai wrapper script
            ai_script = os.path.join(HOME, 'DEGENI', 'bin', 'ai')
            current_model = 'gemini-claude-sonnet-4-5-thinking'
            
            if os.path.exists(ai_script):
                with open(ai_script, 'r') as f:
                    content = f.read()
                    for line in content.split('\n'):
                        if 'ANTHROPIC_DEFAULT_SONNET_MODEL=' in line:
                            current_model = line.split('=')[1].strip()
                            break
            
            self.send_json({'current_model': current_model})
        except Exception as e:
            self.send_json({'error': str(e)}, 500)
    
    def restart_proxy(self):
        """Restart proxy server"""
        try:
            subprocess.run(['pkill', '-9', 'cli-proxy-api'], capture_output=True)
            subprocess.Popen(
                ['nohup', './cli-proxy-api'],
                cwd=PROXY_DIR,
                stdout=open(PROXY_LOG, 'w'),
                stderr=subprocess.STDOUT,
                start_new_session=True
            )
            self.send_json({'success': True, 'message': 'Proxy restarted'})
        except Exception as e:
            self.send_json({'error': str(e)}, 500)
    
    def test_connection(self):
        """Test API connection"""
        try:
            api_key = self._get_api_key()
            result = subprocess.run([
                'curl', '-s', '-X', 'POST', 'http://localhost:8317/v1/messages',
                '-H', f'Authorization: Bearer {api_key}',
                '-H', 'Content-Type: application/json',
                '-H', 'anthropic-version: 2023-06-01',
                '-d', '{"model":"gemini-3-pro-preview","max_tokens":5,"messages":[{"role":"user","content":"hi"}]}'
            ], capture_output=True, text=True, timeout=30)
            
            if 'content' in result.stdout:
                self.send_json({'success': True, 'message': 'Connection OK'})
            else:
                self.send_json({'success': False, 'message': result.stdout[:200]})
        except Exception as e:
            self.send_json({'success': False, 'error': str(e)}, 500)
    
    def toggle_account(self, filename):
        """Enable/disable account"""
        if not filename:
            self.send_json({'error': 'Filename required'}, 400)
            return
        
        try:
            if filename.endswith('.disabled'):
                # Enable
                old_path = os.path.join(AUTH_DIR, filename)
                new_path = old_path.replace('.disabled', '')
                os.rename(old_path, new_path)
                self.send_json({'success': True, 'action': 'enabled', 'filename': os.path.basename(new_path)})
            else:
                # Disable
                old_path = os.path.join(AUTH_DIR, filename)
                new_path = old_path + '.disabled'
                os.rename(old_path, new_path)
                self.send_json({'success': True, 'action': 'disabled', 'filename': os.path.basename(new_path)})
        except Exception as e:
            self.send_json({'error': str(e)}, 500)
    
    def switch_model(self, model):
        """Switch AI model"""
        if not model:
            self.send_json({'error': 'Model required'}, 400)
            return
        
        try:
            ai_script = os.path.join(HOME, 'DEGENI', 'bin', 'ai')
            if os.path.exists(ai_script):
                with open(ai_script, 'r') as f:
                    content = f.read()
                
                # Replace model
                import re
                content = re.sub(
                    r'ANTHROPIC_DEFAULT_SONNET_MODEL=.*',
                    f'ANTHROPIC_DEFAULT_SONNET_MODEL={model}',
                    content
                )
                content = re.sub(
                    r'ANTHROPIC_DEFAULT_OPUS_MODEL=.*',
                    f'ANTHROPIC_DEFAULT_OPUS_MODEL={model}',
                    content
                )
                
                with open(ai_script, 'w') as f:
                    f.write(content)
                
                self.send_json({'success': True, 'model': model})
            else:
                self.send_json({'error': 'AI script not found'}, 404)
        except Exception as e:
            self.send_json({'error': str(e)}, 500)


def run_server():
    server = HTTPServer(('127.0.0.1', PORT), DEGENIHandler)
    print(f"DEGENI API Server running on http://localhost:{PORT}")
    server.serve_forever()


if __name__ == '__main__':
    run_server()
